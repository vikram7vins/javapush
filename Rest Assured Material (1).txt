




API- application Programming interface act as interface betwwen client and sever via json and XML formates

Fron End hotels-------------->Http request--------------->API-------------->Backend code of hotels
				<-------------Http response<-------------API<--------------

Rest Assured is a artitectural design to create API's and below are some of rules to follow
End point/Base url:- Address where API is hosted on server.
Rest is light weighted protocol.

--------------------> API Vs UI
API testing is a software testing technique that tests the APIs. It helps check if the APIs are working fine as expected in terms of functionality, performance, reliability, and security.Unlike UI testing, which tests the look and feel of the application, API testing focuses on the business logic of the application. Also, this testing requires software to send calls to the API.The software will send requests to API, receive output, and compare the actual responses with the expected responses. Thus, it helps check if the API is working correctly.
Benefits of API Testing
API testing is fast and consumes less time as no user interface is required for this testing.
It can improve the overall security of the application as it helps identify security vulnerabilities in the API.
API testing works at the business layer of an application beneath the presentation layer. This helps check the products in-depth, validating if all the system components are working as expected.
API vs UI Testing: The Core Differences
Both testing types play a major role in assuring a product’s quality. Let’s take a quick look at the API vs UI testing differences to understand these concepts better.

UI Testing	                                                     API Testing
Testers perform it	                                             Developers and testers perform it
Functionality of the application is tested	                     The Business Logic of the application is validated
Testing is between the user and front-end of the application	 Testing is between back-end of one application and back-end of another application
It is performed on the presentation layer, i.e., the front-end	 It is performed on the business layer, i.e., the back-end
Slow execution time	                                             Fast execution time
Testers can automate UI tests	                                 Testers can automate API tests

API vs UI Testing: Which is Better?
API and UI testing serve different purposes, but both are important for testing software applications thoroughly. Let’s take a quick glimpse at how these testing could help create a great quality product. API testing focuses on testing an API’s functionality and behavior. Once the functionality of the APIs is thoroughly tested, it is best to automate those tests to ensure faster and more efficient testing.

On the other hand, UI testing focuses on testing the user interface of the application. Here, the QA will test the web UI elements like button color, font size, and style. In general, UI testing is more time-consuming than API testing, as UI testing involves testing every visual aspect of the application. So, once the UI of an application is stable, it is advised to automate the UI tests.

If you are trying to determine which testing is better than the other, then that is unlikely to result in a successful outcome. You need to perform both these testing to ensure the quality and reliability of a software application. Also, they both need to be automated.

Here are some reasons why API automation is considered better than UI automation in certain scenarios:

Faster Execution:
API tests tend to run faster than UI tests because they don’t involve rendering web pages or interacting with the user interface. API requests and responses are typically lightweight, leading to quicker test execution.

Stability:
UI tests can be fragile and sensitive to changes in the user interface, making them prone to breakage when UI elements or layouts change. API tests are generally more stable because they focus on the underlying business logic and data flow.

Coverage:
API tests can provide comprehensive coverage of the application’s functionality, including edge cases and error scenarios. UI tests may not cover all possible user interactions or inputs.

Efficiency:
API tests can be more efficient for repetitive tasks like regression testing or load testing because they require fewer resources and can be run in parallel.

Data Validation:
API tests are well-suited for data validation because they can easily verify the correctness of data returned by the API. UI tests may require additional effort to extract and validate data displayed on the user interface.

Cross-Platform and Cross-Browser Compatibility:
API tests are not dependent on specific browsers or platforms, making them more suitable for testing the backend of applications that need to work across different environments.

Early Detection of Issues:
API tests can be integrated into the development pipeline to catch issues early in the development process, promoting a shift-left approach to testing.

Reduced Maintenance:
UI automation scripts often require frequent updates due to changes in the user interface. API tests tend to have lower maintenance overhead since they are less affected by UI changes.

Scalability:
API automation can easily scale to test multiple endpoints, versions, or services in a micro-services architecture.

Isolation:
API tests can be isolated from the user interface, allowing you to test specific functionalities or endpoints independently. This isolation simplifies debugging and makes it easier to identify the root cause of issues.

CRUD operatios on API:-
~~~~~~~~~~~~~~~~~~~~~~~
 
Get:- used to extract information from server using given URI. while using get request it should only extract data and should no other effect on the data. no payload/body required.

Post:- to send data to server.When your creating something on server.

Put:- Which will replace existing data which already present on server.

Delete:-	Removes all current representations of the target resource given by a URI.			
~~~~~~~~~~~~~~~~~~~~~~~~~
Resources :- It represents API/Collection which can be accessed from server.
BaseURi and resources are mandatory.

Path parameter:- There are variable part of URI and they are typically used to point to specific resource within a collection. such as identified by ID
ex: https://amazon.com/orders/112
https://amazon.com/images/1234321
 orders is resource and 112 is path parameter

Note : If you see in {} , it means that its path parameter. 
Ex: https://jira.com/rest/api/2/issue/{key}/comment

Query parameter:- Used to sort/filter/drill down the resource and query parameter is identified with  '?'

Ex:https://amazon.com/orders?sort_by=20/2/2022
here we are not going to any sub resource like 112, but we are drill down with date

Headers/Cookies:- Represents the metadata associated with Api request and response. in other words sending additional details to API to process our request.
Ex: Authorisation details
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Rest Assured setup for API automation
Rest Assured worked on three principals given(),when(),then()

givem()-->all input details
when()-->submit API
then()-->validate the response

There are some static packages availble in rest assured.for static packages, auto suggestion will not come

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
equalTo() is coming from hamcrest package which is static 

JsonPath: It is class which takes string as input and convert/parse that into jason

THere is situation where you need to save static json in file and using it in our class
Read data from external file:- 
Content of the file to string -> content of file can convert into byte->Byte data to string
Files.readAllbytes(paths.get("c:\\User\\addplace.json")--> it reads the data from external file in the form of bytes
 and then it converts to string by using : new String
body(new String(Files.readAllbytes(paths.get("c:\\User\\addplace.json")))

String response=given(0.log().all().queryparam("key","Value").body(new String(Files.readAllBytes(path.get(path)))).

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Cookie based Authentication
You need to authenticate yourself first and once we recive cookie we can grab and use in sebsequent sessions by sending that as header 
Note: by using headers, cookies, session we can authenticate

Cookie class represents a token or short package ste of information that the http agent and target server can exchange to maintain a session.
ex: Cookie coo=new Cookie.builder("name","value").setcomment("some comment").setExpirydate(somedate).build();
ex: cookies= restassured.given().contenttype().when().body().post().then().statuscode().extract().response().getDetailedCookies();
Restassured.Cookies(cookies).when().post().then().statuscode();
We can also customize our cookie using cookie Builder:

@Test
public void whenUseCookieBuilder_thenOK() {
    Cookie myCookie = new Cookie.Builder("session_id", "1234")
      .setSecured(true)
      .setComment("session id cookie")
      .build();

    given().cookie(myCookie)
      .when().get("/users/eugenp")
      .then().statusCode(200);
}
important
to practice jira API: https://docs.atlassian.com/software/jira/docs/api/REST/7.6.1/#api/2/issue-getissue

A session filter can be used record the session id returned from the server as well as automatically apply this session id in subsequent requests.For example: 
 SessionFilter sessionFilter = new SessionFilter();

 given().
         auth().form("John", "Doe").
         filter(sessionFilter).

Rest assured.BaseURI();
Given().quesrypamameter("").filter(session); 

Sending Attachment through Rest assured :-

using multipart method , we can attach any attachement
Multipart: Specify a file to upload to the server using multi-part form data uploading.It will assume that the control name is file and the mime-type is application/octet-stream.If this is not what you want please use an overloaded method.Parameters:file The file to upload

syntax: given().multiPart("file",new File("file path"));
and need to send header as .header("content-Type","multipart/form-data")

Limiting Json response through query parameters:
given().filter(session).pathparam("key","10123").queryparam("fileds","comment")
Here we are having arounds 41 fields. but by using query parameter we are filtering field only comment
And we have integrate session filters ,pathparmater and query parameters

By Pass HTTPS certicate:-

If you want to talk with application which supports https and required to authenticate with certificate , you need to used below method to by pass.

relaxedHTTPSValidation()
--------------------------------------------------Jsonparsing
jsonpath js=new jsonpath(response);
js.getStrind("ID");



When ever you see [] in json it means it is an array
Step 1: We need to get the Size of it
Another way: 
int commentscount=js.get("fields.comment.comments.size()");
for(int i=0;i<commentscount.size();i++){
js.getint("fields.comment.comments[+i+].id");

}

----------------------------------------------How many ways to send json
Sending static json in three ways: generally body accepts string
1. by using class ex: body(payload.Addplace)    // public class payload{ public static string AddPlace(){}}
2. sending directly into body   Ex: body(" placeid : " "")
3. by using file  Ex:  and then it converts to string by using : new String
body(new String(Files.readAllbytes(paths.get("c:\\User\\addplace.json")))
String response=given(0.log().all().queryparam("key","Value").body(new String(Files.readAllBytes(path.get(path)))).

Handing dynamic json payloads: 
By Sending values and updating json file : ex: body(payload.Addplace("abd","vdgdsf"))
by using paramitirize API test with mutiple data
@Dataprovider(name="BookData"){
return new object[][] {{"a","b"},{"c","d"},{"e","d"}};
}
@Test(dataprovider="bookdata")
public void data(String name,String name1)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Grant types
OAuth 2.0:-Open Authorization”, is a standard designed to allow a website or application to access resources hosted by other web apps on behalf of a user. It replaced OAuth 1.0 in 2012 and is now the de facto industry standard for online authorization.
OAuth 2.0 comes with multiple grant types
a. Authorisation code 
b. Client credentials are most commonly used grant types for OAuth
Authorisation grant type: 


Scope:
Auth_url:
Client_id:
response type:
redirect_uri
state

Step 1: Endpoint to get authorisation code 
Step 2: endpoint to get Access token 

urlEncodingEnabled(false) : asking to rest assured not to convert any special characters to numerics. so we should tell explicitly by using this method
Client Credentials: used Application requests for its own data. if data exchange is between two applications and 99% uses client credentials

Different types of authentications: basic authentication,digest authentication,form authentication, oauth authentication
Basic authentication helps you access the secured APIs and perform actions on the resources.
Rest assured has four types of authentication schemes. They are basic, digest, form, and OAuth authentication.
By default, rest assured uses a challenge-response mechanism. But, a preemptive directive sends the credentials without waiting for the server.
OAuth has two types - OAuth1.0 or OAuth2.0.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Serialisation and De-serialization 
POJO(Plain object java Classes)
Serialisation :Serialisation in Rest assured context is process of converting a java object into request body(Payload)

Rest assured also supports de-serialisation by coverting response body back to java object.

Advantages: 
easy to parse and extract response (jason/xml) values if they are wrapped as java object.
User friendly methods can be created which makes code more readable.
Design approach :
Java object is constructed with the s upport of POJO classes
POJO classes are created based on request/response payload.

Additional libraries required for serialization and deseriliazation:-
For Json: Jackson, Jackson2,Gson or johnZon in classpath 
For XML you need JAXB


defaultParser(parser.Json) class is used to get the response in specified formate.
Ex: given().getParam("access_token","").expect().defaultParser(parser.Json))
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Request Spec Builder
RequestSpecBuilder and ResponseSpecBuilder :It is a class
RequestSpecificatio - it is a interface

Request and response Spec builder:-
Request:
RequestSpeciction request=new RequestSpecBuilder().setContentType(ContentType.JSON).setBaseURI("").addqueryparam("key","qaclick123").build();

ReuestSpeciction :Allows you to specify how the request will look like.It should be return type

give().spec(request).body("")

res=new ResponseSpecBuilder().ExpectedSttusCode().expectContentType(ContentType.JSON).build();

then().spec(res).extract().response();


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Form data
Using multipart : we can sent image.

multipart("productImage",new file("//user//rahul//"))

We can upload images by using form data

Injecting JWT session tokens into API call using postman:-

----------------------------------------------->BlackListheader
it blacklists one or more headers .if these headers showsup during logging , they will be replaced with 'BLACKLISTED'
purpose of blocklist is to prevent sensitive information to be included in log.

given().config(RestAssured.config().logconfig(Logconfig.logconfig().blacklistHeader("Accept").log().headers()
.when().post("")
.then().statuscode(200).statusLine("")
.body("data.email",equalTo("janet.wearear@gmail.com"))
.body("data.firstname",equalTo("janet"))
.body("data.lastname",equalTo("wever")).log().all();

mutiple headers: config(RestAssured.config().logconfig(Logconfig.logConfig().blackListHeader("Accept","Content-Type")))

Map<String,String> mapheaders=new HashMap<String,String>();
mapheaders.put(httpsheaders.contentType,contenttype.json);
mapheaders.put(httpheaders.Accept,contenttype.Any);
RequestSpecification request=given().log().all().headers(mapheaders);

---------------------------------------------->jsonSchema
JSON Schema is a powerful tool for validating the structure of JSON data or your JSON Response. JSON Schema itself is written in JSON. It is data itself, not a computer program. It’s just a declarative format for “describing the structure of other data”.
Step 1: Capture the json response and conevrt reposne into jsonschema
Step 2: Keep in a file and pass that file path into one constant variable.


Ex: 
Step1: String jsonSchema=FileUtils.readFileToString(new File(FileNameConstants.JSON_SCHEMA),"UTF-8");
Step2: Restassured.given().contentType(contentytype.json).baeurl("")
				.when().get("")
				.then().assertthat().statuscode(200)
				.body(JsonSchemaValidator.matchesJsonSchema(jsonSchema));
				
				
-------------------------------------------------->Difference between public API vs private API vs 
Public APIs
Public APIs, also known as open APIs, are available to the general public. They can be used by anyone, regardless of whether they are a customer of the API provider. Public APIs are typically used to provide access to data or services that are intended for broad consumption. Examples of public APIs include social media APIs, such as the Twitter API, and weather APIs, such as the OpenWeatherMap API.

Advantages of Public APIs :
Widespread Adoption: Public APIs are available to a wide range of developers, which can lead to their widespread adoption and use in a variety of applications.
Ease of Use: Because public APIs are open to everyone, they are typically well-documented and easy to use.
Innovation: Public APIs can foster innovation by enabling developers to create new applications and services using the data and services provided by the API.
Use Cases for Public APIs :
Social Media: Social media companies use public APIs to provide access to data about users and their activity on their platforms.
Weather Services: Weather services use public APIs to provide weather data to a variety of applications and services.
Location-Based Services: Location-based services use public APIs to provide information about points of interest, maps, and directions.				

Partner APIs
Partner APIs are designed for a specific group of developers, such as business partners or customers. These APIs are typically used to provide access to data or services that are not intended for broad consumption. Partner APIs require authentication and authorization, and they may also require the use of specific protocols or methods of communication. Examples of partner APIs include the Stripe API, which is used by businesses to process payments, and the Salesforce API, which is used to integrate Salesforce with other business applications.

Advantages of Partner APIs :
Control: Partner APIs enable the API provider to control who has access to their data and services.
Customization: Partner APIs can be customized to meet the specific needs of the partner or customer, enabling them to get the most value from the API.
Security: Partner APIs provide a higher level of security than public APIs, as they require authentication and authorization to access.
Use Cases for Partner APIs :
Business Partnerships: Companies use partner APIs to provide their partners with access to their data and services, enabling them to work together more effectively.
Enterprise Integration: Companies use partner APIs to integrate their business applications with those of their partners or customers, enabling them to share data and services.
Value-Added Services: Companies use partner APIs to provide value-added services to their customers, such as analytics or reporting.

Private APIs :
Private APIs are designed for internal use within an organization. They are not intended for external consumption and are typically used to provide access to data or services that are specific to the organization’s needs. Private APIs may be used to share data between different departments or to enable the development of internal applications. Examples of private APIs include the Google Maps API, which is used internally by Google, and the Amazon S3 API, which is used by Amazon Web Services to provide internal storage and retrieval of data.

Advantages of Private APIs
Control: Private APIs enable an organization to have complete control over their data and services, as they are not intended for external consumption.
Customization: Private APIs can be customized to meet the specific needs of an organization, enabling them to get the most value from the API.
Security: Private APIs provide the highest level of security, as they are not exposed to external threats and can be secured using internal security protocols.
Use Cases for Private APIs
Internal Data Sharing: Private APIs are used to share data between different departments or applications within an organization.
Internal Application Development: Private APIs are used to develop internal applications that access an organization’s data and services.
Legacy System Integration: Private APIs are used to integrate legacy systems with newer systems, enabling the organization to modernize their technology without losing access to valuable data.

FrameWork:
------------------------------------------------------------------------>Maven
Maven: It is a software management and build management tool for java frame work
	1. central repository to get dependecies.
	2. Maintain common structire across the organisation
	3. flexibility in integrating with CI tools 
	4. plugins for test framework execution.

Artifact: artifact is an file ,usaually a JAR that gets deployed to an maven repository.
Group id :group id will identify your project unqiuely across all projects.
Archetype:generate : generate a new project from a achetype
Different tags:
Properties :Maven allows us to define as well as use properties. Properties allow us to avoid hardcoding values in multiple places such as versions of dependencies. They also provide flexibility to the build tool by allowing values to be passed at runtime.
dependencies :provides the capability to manipulate artifacts. It can copy and/or unpack artifacts from local or remote repositories to a specified location
repositories :A maven repository is a directory of packaged JAR file with pom. xml file.
Build :
Plugin :Below is the basic list of tasks that are handled by plugins in maven :
Creating jar/war/ear files.
Code compilation
Unit testing of the code.
Plugins are the building blocks of Maven’s functionality.
They provide implementations for various goals and can be used to extend the build process.
Maven has a vast ecosystem of plugins that cover a wide range of tasks and integrations.
Plugins can be configured in the project’s POM file, specifying the desired version and any custom configurations.
Build Plugins – These plugins will execute during the build phase. These plugins are defined under the <build> element in pom.xml
Report Plugins – These types of plugins are executed during the site generation (report or javadocs generation) phase. These plugins We can configure under the <reporting> element in pom.xml
modules :
Maven life cycle: validate->compile->test->package->integration test->verify->instal->deploy
Validate: This step validates if the project structure is correct. For example – It checks if all the dependencies have been downloaded and are available in the local repository.
Compile: It compiles the source code, converts the .java files to .class, and stores the classes in the target/classes folder.
Test: It runs unit tests for the project.
Package: This step packages the compiled code in a distributable format like JAR or WAR.
Integration test: It runs the integration tests for the project.
Verify: This step runs checks to verify that the project is valid and meets the quality standards.
Install: This step installs the packaged code to the local Maven repository.
Deploy: It copies the packaged code to the remote repository for sharing it with other developers

mvn clean:clean project and removes all previous file
mvn compile: compiles source code
mvn test-compile:compiles the source code
mvn test-runs test for project 
mvn install deploys the package JAR or WAR file for the project to convert into distributable format

Maven Surefire Plugin:
a. Maven sure fire plugin is used to follow the sequence of tests in testng.xml file. 
b. If we don't include the Mavwen surefire plugin then it will execute all the testcases under src/test/java which has prefix or suffix as 'test' and these tests will get executed without any sequence.
c. Surefire Plugin gives additional control or flexibility of what test cases are needed to include, what to execute, what to skip, parallelism, excluding groups, defining group and thread-count, etc.
------------------------------------------------------------------------------------------------------------------------>Cucumber
It allows business analysts, developers, testers, etc. to automate functional verification and validation in an easily readable and understandable format (e.g., plain English).
Cucumber:  whenever you develop a automation script you need to come up with some execution system to run and maintain automation script.
Behavirol driven development framework to run and maintain script.
We need natural plug in for cucumber and cucmber project skeleton can by obtained by maven. template name : quick start template 
Need cucucmber-java and cucumber-junit
Tiddy jerkin plug will generate step definition methods

We need to create step definition and feature file under src/test/java

Feature,stepdefinition and test runner files are important 

If you want to send multiple data we need to use Scenario Outline
Exmaples: used to data driven
Examples:
	|name|language|address|
	|AAhouse|English|world class center|

test runner : 
@Runwith(cucumber.class)
@cucumberoptions{
	feature="src/test/java"
	glue="stepdefinition"

}

Tags : @is ued to declare tags
tags are used to kepp them in one group we can use groups
Ex: 
@regression @smoke @sanity
Scenario: search content

multiple Tags can be done by using AND/OR operator
OR : 
Ex: tags ={"@regression, @smoke "}
And :if the application has passed in the first test, then jump to check the next test, but if it gets failed, then testing should be terminated.
Ex: tags={"@regression" ,"@sanity"}  //when we are using and we need to mention ""
Ignore tags : tags={"@regression, ~@smoke"} 
Background : It is used to eliminate duplicate steps.
Datatables :DataTables are also used to handle large amounts of data
Data tables are used when we need to test numerous input parameters of a web application. For example, the registration form of the new user involves several parameters to test, so for this, we can use the data table.
Ex: given unser on the registration page
when user enter valid data in regrestion form
|Fields|Values|
|First name| sudheer|
|Lastname||
|DOB||
Hooks :hook is the block of code which can be defined with each scenario in step definition file by using the annotation @Before and @After. 
 Hooks can be defined only in the step definition file.

Following Main Options are available in Cucumber:
Dryrun : true-checks if all steps have step defnitions
glue: 
feature:
tags: what tags in the feature shuold be execute
monochrome: display console output in much readable way
formte: 
Strict: will fail execution if ther are undefined or pending steps
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Logging:-
Syntax: 
We need to log into seperate file .so By using Printstream class create one object 
Using FileOutputStream we need to create one file 
PrintStream log=New PrintStream(new FileoutputStream("logging.txt"));
addFilter(requestLoggingFilter.logRequestTo(log));

ex: RestAssuredBaseURI="http://"

req=new RequesSpecBuilder().setBaseURI("https://").addQueryparam("").addFilter(requestloggingFilter).setContentType("").build();
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Global properties 
Reading data from property file :

by using Properties class
Properties prop=new Properties();
FileInputStream fis=new FileInputStream("c:\\users\\");
prop.load(fis);
prop.getProperty(baseURL);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Data driven mechanism

Enum is special class in java which has collection of constants or methods

public enum APIResources{
addplaceAPI("/maps/api/place/add"),
deleteplaceAPI("/maps/api/place/get/json"),
getplaceAPi("/maps/api");
}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Hooks
@creditcard
@debitcard

@cucumberOptions(@feature="src/test/java/feature", glue={"stepDefinition"}, tags={"@Creditcard"})


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Running through Mvn command
Navigate to project path : Cd c:\users\sudheer\restassured
 mvn compile --->compile only project
 mvn test -->compile and run
It will pick which present in src/test/java
it will check cucumber.Options package

If you want pass parameter , you need to start with -D
Syn: mvn test -Dcucumber.Options="--tags @creditcard"

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Reporting
maven cucumber reporting- damianszczepanik

Verify- it is phase present in maven , it will execute once after all execution
ex: compile -->test--verify

to get reports using cucumber:


@cucumberOptions(feature="src/test/java/feature", glue={"stepdefinitions"}, plugin="json:target/jsonReports/cucmber-report.json")


mvn verify -you need provide verify phase
mvn test verify

You need provide below dependencies in pom .xml
https://github.com/damianszczepanik/maven-cucumber-reporting

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Graph QL
GraphQL is a query language and server side runtime for fulfilling those queries on your existing data .
Graph Ql isn't tied to any specific database or storage engine and is instead backed by your existing code and data 
adv:
1. can avoid over fetching and under fetching 
2. perfomance 

GraphQL schema:

type : like class 
fields
arguments

graph QL explorer 
please ask developed that documentation/ graph ql server explorer link 


~~~~~~~~~~~~~~~~~~~~~~~~~~~APACHE POI API
Fileinputstream is a class which has power to read any file 
XSSFWorkBook is a class which have control over excel and have methods to get data

